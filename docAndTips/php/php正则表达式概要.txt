\	将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符

()	用来把几个正则表达式组合为一个单元,可以使用(|)指定可供选择的部分即"或"操作;
(pattern) 匹配pattern，并获取这一匹配（可用\num提取）
(?:pattern)匹配pattern，但不获取匹配结果

pattern(?=sub_pattern)匹配pattern字符串的后面也要同时匹配sub_pattern，例如：
foo(?=bar)匹配后面带有bar的foo，它可以匹配foobar,abcfoobar中的foo，但不能匹配fooabc中的foo

pattern(?!sub_pattern)匹配pattern字符串的后面不能匹配sub_pattern,例如：
foo(?!bar)匹配后面不带bar的foo，它可以匹配foo123,但是不能匹配：foobar

(?<=sub_pattern)pattern匹配pattern字符串的前面也要同时匹配sub_pattern，例如：
(?<=foo)bar匹配前面有foo的bar，它可匹配foobar,123foobar中的bar，但不能匹配123bar中的bar

(?<!sub_pattern)pattern匹配pattern字符串的前面不能匹配sub_pattern,例如：
(?<!foo)bar匹配前面没有foo的bar，它可以匹配123bar中的bar，不能匹配foobar,123foobar中的bar

注意：所有的预查都是非获取匹配，不消耗字符。也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始

#########################################################################################

.	匹配除"\n"之外的任何单个字符
* 	匹配前面的子表达式零次或多次
? 	匹配前面的子表达式零次或一次
+ 	匹配前面的子表达式一次或多次
{n}	匹配前面的子表达式n次
{n,}	匹配前面的子表达式至少n次
{n,m}	匹配前面的子表达式至少n次且最多m次（在逗号和m之间不能有空格）

^ 	匹配输入字符串的开始位置。若在方括号内的开始处则表对方括号表达式做逻辑‘非’操作
$ 	匹配输入字符串的结尾位置
\b 	在单词的边界上匹配，  如'er\b'能匹配"never"中的'er'，但不能匹配"verb"中的'er'
\B 	在单词的中间匹配，如'er\B'能匹配"verb"中的'er'，但不能匹配"never"中的'er' 
\cx 	匹配由x指明的控制字符。如\cM匹配Ctrl-M即回车符。x为[a-zA-Z]否则c将视为一个原义字符
\xn 	匹配n(n为两位十六进制值)，如'\x41'匹配"A"（41的十进制值是65）
\un 	匹配n(n为四位十六进制表示的Unicode字符)。如\u00A9匹配版权符号
\num 	匹配num(num为正整数)。对所获取的匹配的引用。如'(.)\1'匹配两个连续的相同字符
\d 	匹配一个数字字符。等价于[0-9]
\D 	匹配一个非数字字符。等价于[^0-9]
\f 	匹配一个换页符。等价于\x0c和\cL
\n 	匹配一个换行符。等价于\x0a和\cJ
\r 	匹配一个回车符。等价于\x0d和\cM
\t 	匹配一个制表符。等价于\x09和\cI 
\v 	匹配一个垂直制表符。等价于\x0b和\cK 
\s 	匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]
\S 	匹配任何非空白字符。等价于[^\f\n\r\t\v]
\w 	匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'
\W 	匹配任何非单词字符。等价于'[^A-Za-z0-9_]'。 


例子 :
/\b([a-z]+)\1\b/gi 一个单词连续出现的位置 
/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/ 将一个URL解析为协议、域、端口及相对路径 
/^(?:Chapter|Section) [1-9][0-9]{0,1}$/ 定位章节的位置 
/[-a-z]/ A至z共26个字母再加一个-号。 
/ter\b/ 可匹配chapter，而不能terminal 
/\Bapt/ 可匹配chapter，而不能aptitude 
/Windows(?=95 |98 |NT )/ 可匹配Windows95或Windows98或WindowsNT,当找到一个匹配后，从Windows后面开始进行下一次 
^[a-zA-Z0-9_]+$ //所有包含一个以上的字母、数字或下划线的字符串 
^[0-9]+$ //所有的正数 
^\-?[0-9]+$ //所有的整数 
^\-?[0-9]*\.?[0-9]*$ //所有的小数 






